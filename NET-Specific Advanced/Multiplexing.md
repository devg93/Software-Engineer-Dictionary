მოკლედ: **Multiplexing** ნიშნავს მრავალ „ლოგიკურ ნაკადს“ (streams) ერთ ფიზიკურ კავშირზე. HTTP/2-ში და HTTP/3-ში ეს გაძლევს საშუალებას, ერთ TCP/QUIC კავშირზე პარალელურად გაგზავნო ბევრი მოთხოვნა/პასუხი — head-of-line blocking-ის გარეშე (HTTP/3-ში TCP-ს დონეზეც აღარ გვაქვს HoL, რადგან QUIC-ია).

# რას ნიშნავს პრაქტიკაში

- **HTTP/1.1:** ერთ კავშირზე მოთხოვნები რიგდებით (keep-alive + pipelining რეალურად იშვიათად მუშაობდა). პარალელიზაციაში ბრაუზერები/კლიენტები ხსნიდნენ **რამდენიმე TCP კავშირს** ერთ დომენთან.
    
- **HTTP/2 (TCP):** ერთი TCP კავშირი → ბევრი **stream** (request/response) პარალელურად. თითო stream-ს აქვს საკუთარი ID, flow-control და პრიორიტეტები. მინუსი: თუ TCP პაკეტები დაიკარგა, იმავე კავშირზე ყველა stream ელის (TCP HoL).
    
- **HTTP/3 (QUIC/UDP):** იგივე stream-ები, მაგრამ TCP-ის HoL აღარ მოქმედებს — დაკარგული პაკეტი აფერხებს მხოლოდ შესაბამის stream-ს, სხვები აგრძელებენ.
    

სად გამოიყენებ:

- **ASP.NET Core/Kestrel** — იგივე პორტზე გაუშვებ HTTP/1.1 + HTTP/2 (+ HTTP/3) და ერთ კავშირზე მოემსახურები მრავალი პარალელურ მოთხოვნას, რაც ამცირებს TLS handshakes/კავშირების რაოდენობას და latency-ს.
    
- **gRPC** — დიზაინით ეყრდნობა HTTP/2/3 multiplexing-ს; ბევრი unary/stream کالები ერთ კავშირზე.
    
- **ბროსერი/CDN** — დიდი რაოდენობით მცირე რესურსები (API, GraphQL, SSE, WebTransport).
    

> არ ავურიოთ: **I/O multiplexing** (select/poll/epoll/kqueue) — ოპერაციული სისტემის პრიმიტივებია „რამდენიმე descriptor-ის“ ზედმოჭიდების გარეშე მონიტორინგისთვის. HTTP multiplexing — აპლიკაციური დონის კონცეფცია, სადაც ერთი კავშირი დაყოფილია მრავალ სტრიმად