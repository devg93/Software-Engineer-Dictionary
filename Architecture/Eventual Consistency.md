Eventual Consistency — ეს არის მოდელი, სადაც სისტემა **მყისიერად არა**, არამედ **დროთა განმავლობაში** მოდის თანხვედრაში: ყველა რეპლიკა/ქეში საბოლოოდ დაინახავს ერთსა და იმავე მნიშვნელობას, მაგრამ მოკლე პერიოდში წაკითხვამ შეიძლება დააბრუნოს **ჩამორჩენილი (stale)** მონაცემი.

# რა დროს ვიყენებთ

- გლობალური მასშტაბირება და დაბალი ლატენტობა (მრავალრეგიონული რეპლიკაცია).
    
- მაღალტრაფიკიანი წაკითხვები ქეშებიდან (Redis) ან materialized view-ებიდან.
    
- Event-driven არქიტექტურა (CQRS/ES), სადაც Write-მოდელი და Read-მოდელი განცალკევებულია და სინქრონიზდება ასინქრონული ივენთებით.
    

# გარანტია და ანომალიები

- **გარანტია:** თითო key საბოლოოდ გახდება თანმიმდევრული ყველა კოპიაზე (თუ ახალი ჩაწერები არ ხდება და ქსელი „გამოჯანმრთელდა“).
    
- **შეიძლება მოხდეს:** stale reads, non-monotonic reads, read-your-writes დარღვევა, დროებითი კონფლიქტები (multi-master).
    

# .NET/Cloud მაგალითები

- **Azure Cosmos DB** consistency levels: Strong → BoundedStaleness → **Session** → ConsistentPrefix → **Eventual**. პროდუქტიულად ხშირად ირჩევენ **Session** (read-your-writes ერთი სესიის ფარგლებში) ან Eventual დაბალი ლატენტობისთვის.
    
- **CQRS + RabbitMQ/Kafka**: ბრძანება წერს Write store-ში → აქვეყნებს ივენთს → პროექტორი აახლებს Read store-ს. მომხმარებლის კითხვა შეიძლება დაებრუნოს ძველი სურათი სანამ პროექტორი დასრულდება.
    
- **Redis Cache**: write-through/write-behind/TTL ინვალიდაცია — ქეში და DB შეიძლება დროებით აცდენილი იყოს.
    

# დიზაინ-პრაქტიკები (trade-offs)

**პლუსები:** მასშტაბირება, ხელმისაწვდომობა, იაფი/სწრაფი წაკითხვები, რეგიონული ლატენტობის შემცირება.  
**მინუსები:** stale მონაცემები, კომპლექსური დათანხმება, კონფლიქტების გადაწყვეტა (CRDT/merge), უფრო რთული ტესტირება/observability.

**შეთავაზებული პატერნები**

- **CQRS + Outbox** (exactly-once მთლიანი სისტემის ნაცვლად → effectively-once პროდიუსერში).
    
- **Idempotent consumer** (დუბლიკატური ივენთები უსაფრთხოა).
    
- **Optimistic concurrency** ETag/RowVersion-ით.
    
- **Polly retries** ტრანზიტორული შეცდომებისთვის.
    
- **User-visible consistency**: UI აჩვენებს „Processing…“ სანამ projection განახლდება ან თავაზობს „Refresh“/„Notify“.